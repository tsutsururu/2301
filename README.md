# 2301

# 278E Grid Filling   diff 996

解答遷移 AC

計 58:54

備考

➀　思考

(H-h+1)(W-w+1)個のマスすべてに対して、隣接hw マスを全操作すればこの問題に解答できるが、計算量は O( 10^8 ) になるので不可能。⇒ 次のマスの隣接マスと重複している領域は新しく探索する必要がないことに注目。 これによって O( h(W-w) ) で同じ行について調べられる。行を更新する際は、前の行の初めの状態を覚えておいてそれを更新する。これによって、全体での操作回数は Nhw : 初めの隣接hw マスの調査 + h(W-w)(H-h+1) : 列方向での調査 + w(H-h) 行の更新 となって、計算量は O(10^6) に改善できた。

➁ 別解

類題 129D Lump


# 0120

# 285C abc285_brutmhyhiizp    diff　157

解答遷移 AC

計 13:38

備考

➀　思考

長さ L の文字列の場合、L-1 以下の文字列は Σ 26^k 個存在する。また、L文字の文字列の順番を求めるためには先頭の文字から順に、何番目の文字列か に注目する。例えば、先頭が C の場合、AAA...A ～ CAA...A までに、2* 26^(L-1) 個存在するので、これを最後の文字に至るまで繰り返すことで順番を特定した。


➁ 別解

26進数で考える。すると、例えば ABC の場合、3桁の文字列の中で 012(26) 番目と考えることができる。

その桁以下の文字列を考量する必要があるが、これは各桁の値を +1 することで実現が可能。1桁目はこの限りではないが、index揃えで +1 するので、すべての桁でこの処理を施せばよい。ABC は 123(26) 番目となる

後はこの26進数の番号を10進数に変換すればよい。


関連問題

171C One Quadrillion and One Dalmatians (逆処理)

216C Many balls (逆処理 2進数 ver)



# 266B Modulo Number  diff  95

解答遷移 AC

計 05:49

備考

➀　思考

x= N (mod) に気が付いてAC

# JSC2021  Xor of Sequences  diff 51

解答遷移 AC

計 05:03

備考

➀　思考

Atcoder では計算量の観点から集合演算が最適解になることはないので、これは避けて解答したかった。⇒ ありえる数を全探索して、条件を満たすか判定すればよいと判断 ⇒ AC


# 0121

# 216C Many Balls   二回目  diff 145

解答遷移 AC

備考

➀　思考

N から 0 を目標に操作を行う。2で割っていくのもよいが、Nを2進数で表記すれば、各桁が 1 なら操作 A が必要と判断するシミレーションを行えると考えた。

なお、逆順では deque が有効と考えたが、最終的な文字列の結合を厳密に行う場合( 一番最初の 操作B を取り除く場合)、deque はリストと異なりスライスできないので注意。

➁ 別解

上から見ていけば逆順処理は必要なくなる


# 171C One Quadrillion and One Dalmatians    2回目  diff 560

解答遷移 AC

備考

➀　思考

桁数を特定し、その桁の中で何番目なのかわかれば名前を決定できると判断。⇒ まず桁数を特定し、その過程でその桁以下の名前の総数を引いていく。後はその求めるべき番号を 26進数で表記すれば、各桁のアルファベットを上から求められると判断した。


➁ 別解

その桁の中で何番目か求めることは、各桁を -1 することに一致する。また、26で割った余りに注目することで下の桁からアルファベットを特定できる。これによって桁数を求めることなく、文字列を特定することができる。


類題 

216C Many Balls ( 2進数 ver )   

関連問題

285C abc285_brutmhyhiizp (逆処理)


# 最短経路問題　～ BFS  vs  ダイクストラ  vs 01-BFS　～

## 実装編

BFS は全辺の重さが等しいグラフにおける単一始点の最短経路を求めることができる。暫定最短距離が更新されることがないので、que に同じ頂点が格納されることはないので、queから取り出した頂点が最短経路をなすか考量する必要がないぶん実装が簡単

ダイクストラ法は、全辺が非負の重さをもつグラフにおける単一始点の最短経路を求めることができる。暫定最短距離が更新されることがあるので、[最短経路のコスト、次の頂点] をヒープに入れていくと、ヒープから取り出した頂点が最短経路をなさない場合がある。よって、これをコストと現在の暫定最短距離で判定する処理が必要。

01-BFS は全辺の重さが 0 or 1 のグラフにおける単一始点の最短経路を求めることができる。 次の辺が 0 なら 頂点を管理する deque の頭に、1 なら後ろに 注目する頂点を格納していくことで、最短経路を探索するための正しい順番を形成できる。ダイクストラ法同様、暫定最短距離は更新されるが、コストを格納しない場合、頂点の情報のみではその頂点が探索済か判断することができない。⇒ 頂点の重複探索を許してしまい deque に格納する部分で判定するか、コストの情報も管理することにするか、あるいは最短距離リストとは別で探索済みリストを作成することで判断するか することになると考える (230122現在)

まとめると、

まず、次に探索する頂点を格納したデータ構造から頂点を取り出し、BFSでなければコストなどで暫定最短距離と比較する。この条件をクリアできたら、次の頂点を探索し、その頂点の暫定最短距離を更新することができるならデータ構造に格納する。この一連の流れを、各アルゴリズムで適切なデータ構造を用いて行えばよい。



https://betrue12.hateblo.jp/entry/2018/12/08/000020


## 意識編   0126 213E解答後

BFS は辺の重みが全て等しいので、探索アルゴリズムとして考えてもよいが、01-BFS および ダイクストラ法 は適切な重みの辺を順番に頂点間に貼り、グラフを構築するイメージを持つ必要がある。

# 0125

# ☆ 246E　Bishop 2　　diff  1476

解答遷移 TLE WA AC

計 38:51 + 10:00

備考

➀ 思考

いけるところまでいく BFS で解答できると考えたが計算量が O(N^3) になり TLE ⇒ 行先の暫定最短距離 > 現在地の最短距離 +1 でなければ打ち止めることで計算量を改善できると考えたが WA ⇒ 下図のような例で 行先の暫定最短距離 = 現在地の最短距離 +1 の場合に打ち止めてしまうのではなく、その先を見る必要があることに気づいて、行先の暫定最短距離 < 現在地の最短距離 +1 の場合に打ち止めることにして AC

なお、解答時は計算量推定する余裕はなく、6sec だしいけるやろで提出している。

改善した実装では、対角線の探索が一度切りで、各頂点から 4方向の頂点を探索すると考えると計算量は全体で O(2(2N+1) + 4N^2) であると推定できる。
 
![image](https://user-images.githubusercontent.com/109026838/214480828-b9702512-1db3-46fe-ab48-30d93af8efab.png)

➁ 解法

現在地に到達した方向と同じ方向の頂点と連結する辺の重みを 0 , それ以外の辺の重みを 1 としてグラフを構築して 01BFS をすることでこの問題を解答できる。

ただし、現在地に到達した方向次第で同じ行き先であっても辺の重みが変化してしまう。そこで頂点を(x座標,y座標,直前の方向) で管理することにする。この工夫でグラフはとてもシンプルになる

![image](https://user-images.githubusercontent.com/109026838/214483970-d8533b1f-edb2-4392-acb2-433ce6e18c07.png)

もしこの工夫を施さないとすると、重み1 の辺で連結している行き先の頂点の更新条件を 行き先の暫定最短距離 ≧ 現在地最短距離 +1 とすることで全方向を考慮する対策が考えられる。しかし、この方法では結局、方向ごとに暫定最短距離を持つことができず、行き先の暫定最短距離の予期しない更新が生じてしまう。

![image](https://user-images.githubusercontent.com/109026838/214486873-8740c712-b772-4c29-ae14-bd01ccc207dc.png)

また、直前の方向の情報を含めて頂点を管理する場合、頂点数は 4×2×N^2 (4方向 × 暫定最短距離 x , x+1 の2種) なので計算量は O(2V) = O(8E) = O(1.44×10^8) となるが、更新条件を緩くした方針では、頂点数は 16×4×N^2 になるので、全体で O(1.1×10^9) となって全く間に合わない。

③ 感想

グラフの構築の観点から、状態の情報で頂点を管理する意義を理解することができた。また、更新条件を緩くすると想定以上に計算量が増加してしまうことを理解出来た。


# 0126

# ☆ 213E  Stronger Takahashi   diff 1423

備考

➀　思考

道ならコスト0 、壁ならコスト1で移動するので、01-BFSで解答できると考えた。しかし、今回の壁を破壊して移動する処理に癖があり一筋縄ではいかない ⇒ あるマスを破壊する場合、そのマスを左上、左下、右上、右下に設定する4通りが考えられるので、頂点数を4倍する処理を考えた。しかしこれではずっと同じ破壊を繰り返す(異なる種類の破壊が共存しない)ことになって適切ではないと判断した。⇒ そのマスを中心とした 3×3 のマスへは距離 1 でいけることに気が付いた。

ただし、隣接4マス以外のこれら 3×3　マスをどのタイミングで que に格納すべきか非常に難しかった。つまり、現在いるマスが壁の場合これらを探索することにすべきか、隣接4マスが壁の場合に追加でこれらのマスも探索すべきかである。前者の場合、壁のとき 3×3 マスを現在地と同じ最短距離に更新することになるがこれでは連続で壁を移動する場合コストが生じなくなってしまう(サンプル3で距離1になる)。そこで壁からの移動後に 3×3のマスを全て道に変更することも考えたが、この場合もこの場合で本来壁であったマスが道になることで適切に移動できなくなってしまった。後者の場合も、隣接マスが同じ最短距離の場合に、3×3マスの更新がうまくできなかった。

ここで降参


➁ 解法

まず、方針は◎

壁移動の範囲をすばやく判断すること、適切にグラフを構築することができなかったことが敗因。

辺の重みを意識しない BFS とは異なり、01-BFS やダイクストラ法ではグラフを構築する意識を持つ必要がある。つまり、マスから移動可能なマスに向かって辺を貼っていく意識である。

隣接4マスが壁の場合、確かに隣接マスを中心とした 3×3 の範囲のマスが移動可能だが、これは隣接マスからではなく始点からコスト1で行けるマスである。したがって、始点から辺を貼る必要がある。

![image](https://user-images.githubusercontent.com/109026838/214760527-53c67c9d-5334-4acd-973c-4f9fe87cabd8.png)














